{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-5aeb4b5b86b522a3e1f88aa48b174383d090deef",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/SimpleMint.sol": "project/contracts/SimpleMint.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@gelatonetwork/relay-context/=npm/@gelatonetwork/relay-context@4.1.1/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@4.9.3/"
      ]
    },
    "sources": {
      "npm/@gelatonetwork/relay-context@4.1.1/contracts/vendor/ERC2771Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (metatx/ERC2771Context.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Context variant with ERC2771 support.\n */\n// based on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/metatx/ERC2771Context.sol\nabstract contract ERC2771Context {\n    address private immutable _trustedForwarder;\n\n    constructor(address trustedForwarder) {\n        _trustedForwarder = trustedForwarder;\n    }\n\n    function isTrustedForwarder(address forwarder)\n        public\n        view\n        virtual\n        returns (bool)\n    {\n        return forwarder == _trustedForwarder;\n    }\n\n    function _msgSender() internal view virtual returns (address sender) {\n        if (isTrustedForwarder(msg.sender)) {\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\n            /// @solidity memory-safe-assembly\n            assembly {\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\n            }\n        } else {\n            return msg.sender;\n        }\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        if (isTrustedForwarder(msg.sender)) {\n            return msg.data[:msg.data.length - 20];\n        } else {\n            return msg.data;\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@4.9.3/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
      },
      "project/contracts/SimpleMint.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"@gelatonetwork/relay-context/contracts/vendor/ERC2771Context.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\n/**\n * @title SimpleMint\n * @dev A simple minting contract that supports ERC2771 for gasless transactions\n * Users can mint tokens to any address, and the contract tracks minting stats\n */\ncontract SimpleMint is ERC2771Context {\n    // Events\n    event TokenMinted(address indexed minter, address indexed recipient, uint256 tokenId);\n    event BatchMinted(address indexed minter, address indexed recipient, uint256 quantity);\n    \n    // State variables\n    uint256 public totalSupply;\n    uint256 public nextTokenId = 1;\n    \n    // Mapping from token ID to owner\n    mapping(uint256 => address) public ownerOf;\n    \n    // Mapping from owner to token count\n    mapping(address => uint256) public balanceOf;\n    \n    // Mapping to track how many tokens each address has minted\n    mapping(address => uint256) public mintedBy;\n    \n    // Optional: Mint limits\n    uint256 public constant MAX_MINT_PER_USER = 10;\n    uint256 public constant MAX_TOTAL_SUPPLY = 1000;\n    \n    /**\n     * @dev Constructor sets the trusted forwarder for ERC2771\n     * @param trustedForwarder The address of Gelato's trusted forwarder\n     */\n    constructor(address trustedForwarder) ERC2771Context(trustedForwarder) {}\n    \n    /**\n     * @dev Mint a single token to the specified recipient\n     * @param recipient The address to receive the minted token\n     */\n    function mint(address recipient) external {\n        require(recipient != address(0), \"SimpleMint: mint to zero address\");\n        require(totalSupply < MAX_TOTAL_SUPPLY, \"SimpleMint: max supply reached\");\n        require(mintedBy[_msgSender()] < MAX_MINT_PER_USER, \"SimpleMint: max mint per user reached\");\n        \n        uint256 tokenId = nextTokenId;\n        \n        // Update state\n        ownerOf[tokenId] = recipient;\n        balanceOf[recipient]++;\n        mintedBy[_msgSender()]++;\n        totalSupply++;\n        nextTokenId++;\n        \n        emit TokenMinted(_msgSender(), recipient, tokenId);\n    }\n    \n    /**\n     * @dev Mint a single token to the caller\n     */\n    function mintToSelf() external {\n        address recipient = _msgSender();\n        require(recipient != address(0), \"SimpleMint: mint to zero address\");\n        require(totalSupply < MAX_TOTAL_SUPPLY, \"SimpleMint: max supply reached\");\n        require(mintedBy[recipient] < MAX_MINT_PER_USER, \"SimpleMint: max mint per user reached\");\n        \n        uint256 tokenId = nextTokenId;\n        \n        // Update state\n        ownerOf[tokenId] = recipient;\n        balanceOf[recipient]++;\n        mintedBy[recipient]++;\n        totalSupply++;\n        nextTokenId++;\n        \n        emit TokenMinted(recipient, recipient, tokenId);\n    }\n    \n    /**\n     * @dev Mint multiple tokens to the specified recipient\n     * @param recipient The address to receive the minted tokens\n     * @param quantity The number of tokens to mint\n     */\n    function batchMint(address recipient, uint256 quantity) external {\n        require(recipient != address(0), \"SimpleMint: mint to zero address\");\n        require(quantity > 0 && quantity <= 5, \"SimpleMint: invalid quantity (1-5)\");\n        require(totalSupply + quantity <= MAX_TOTAL_SUPPLY, \"SimpleMint: would exceed max supply\");\n        require(mintedBy[_msgSender()] + quantity <= MAX_MINT_PER_USER, \"SimpleMint: would exceed max mint per user\");\n        \n        uint256 startTokenId = nextTokenId;\n        \n        // Update state\n        for (uint256 i = 0; i < quantity; i++) {\n            ownerOf[startTokenId + i] = recipient;\n        }\n        \n        balanceOf[recipient] += quantity;\n        mintedBy[_msgSender()] += quantity;\n        totalSupply += quantity;\n        nextTokenId += quantity;\n        \n        emit BatchMinted(_msgSender(), recipient, quantity);\n    }\n    \n    /**\n     * @dev Get the minter (original sender) of a transaction\n     * This demonstrates that _msgSender() returns the original user, not the relayer\n     */\n    function getMinter() external view returns (address) {\n        return _msgSender();\n    }\n    \n    /**\n     * @dev Check how many tokens a user can still mint\n     */\n    function remainingMintsFor(address user) external view returns (uint256) {\n        uint256 minted = mintedBy[user];\n        return minted >= MAX_MINT_PER_USER ? 0 : MAX_MINT_PER_USER - minted;\n    }\n    \n    /**\n     * @dev Check if minting is still available\n     */\n    function mintingAvailable() external view returns (bool) {\n        return totalSupply < MAX_TOTAL_SUPPLY;\n    }\n    \n    /**\n     * @dev Override _msgSender to use ERC2771Context implementation\n     * This ensures we get the original sender, not the relayer\n     */\n    function _msgSender() internal view override returns (address sender) {\n        return ERC2771Context._msgSender();\n    }\n    \n    /**\n     * @dev Override _msgData to use ERC2771Context implementation\n     */\n    function _msgData() internal view override returns (bytes calldata) {\n        return ERC2771Context._msgData();\n    }\n}\n"
      }
    }
  }
}